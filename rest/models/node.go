// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/SKF/go-utility/v2/uuid"
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Node node
//
// swagger:model Node
type Node struct {

	// Possible answers for single_choice and multi_choice inspections. Only valid for inspection point type nodes
	Answers []string `json:"answers"`

	// Only valid for asset type nodes
	AssetClass string `json:"assetClass,omitempty"`

	// Only valid for asset type nodes
	AssetSequence string `json:"assetSequence,omitempty"`

	// Only valid for asset type nodes
	AssetType string `json:"assetType,omitempty"`

	// Bearing number on this asset. Only valid for measurement point type nodes
	Bearing int64 `json:"bearing,omitempty"`

	// Which country the node is in. Only valid for site type node
	Country string `json:"country,omitempty"`

	// Only valid for asset type nodes
	Criticality string `json:"criticality,omitempty"`

	// Type of device used to take measurements on this point. Only valid for measurement point type nodes
	DadType string `json:"dadType,omitempty"`

	// Description of the node
	Description string `json:"description,omitempty"`

	// Speed in RPM if this shaft has a fixed speed. Only valid for measurement point type nodes
	FixedSpeedRpm float64 `json:"fixedSpeedRpm,omitempty"`

	// ID of node, as a UUID
	ID uuid.UUID `json:"id,omitempty"`

	// Industry segment of this node. Only valid for site type node
	// Enum: [agriculture construction food_and_beverage hydrocarbon_processing machine_tool marine metal mining power_generation pulp_and_paper renewable undefined]
	IndustrySegment string `json:"industrySegment,omitempty"`

	// Descriptive name of the node
	Label string `json:"label,omitempty"`

	// ID of measurement point location. Only valid for measurement point type nodes
	LocationID uuid.UUID `json:"locationId,omitempty"`

	// Type of lubricant used. Only valid for lubrication point type nodes
	Lubricant string `json:"lubricant,omitempty"`

	// Unit that the volume is specified in. Only valid for lubrication point type nodes
	// Enum: [gram ounce cm3 unknown]
	LubricantUnit string `json:"lubricantUnit,omitempty"`

	// Volume of lubricant, in the given unit. Only valid for lubrication point type nodes
	LubricantVolume int64 `json:"lubricantVolume,omitempty"`

	// Instruction for lubrication activity. Only valid for lubrication point type nodes
	LubricateInstructions string `json:"lubricateInstructions,omitempty"`

	// Interval between lubrication in days. Only valid for lubrication point type nodes
	LubricateInterval int64 `json:"lubricateInterval,omitempty"`

	// ActivityAssetState the asset should be in during the lubrication activity. Only valid for lubrication point type nodes
	// Enum: [must_be_on must_be_off]
	LubricationActivityAssetState string `json:"lubricationActivityAssetState,omitempty"`

	// Only valid for asset type nodes
	Manufacturer string `json:"manufacturer,omitempty"`

	// Type of measurement. Only valid for measurement point type nodes
	// Enum: [displacement acceleration velocity temperature dc_gap ampl_phase box speed envelope_2 envelope_3 unknown]
	MeasurementType string `json:"measurementType,omitempty"`

	// Metadata with keys and optional values
	MetaData NodeMetaData `json:"metaData,omitempty"`

	// Only valid for asset type nodes
	Model string `json:"model,omitempty"`

	// Type of node
	// Enum: [root company site plant ship system functional_location asset measurement_point inspection_point lubrication_point]
	NodeSubType string `json:"nodeSubType,omitempty"`

	// Type of node
	// Enum: [root company site plant system functional_location asset measurement_point inspection_point lubrication_point unknown]
	NodeType string `json:"nodeType,omitempty"`

	// Orientation of measurement. Only valid for measurement point type nodes
	// Enum: [axial radial radial90 horizontal vertical unknown]
	Orientation string `json:"orientation,omitempty"`

	// Origin of node, if imported from another system
	Origin *Origin `json:"origin,omitempty"`

	// ID of parent node, as a UUID
	ParentID uuid.UUID `json:"parentId,omitempty"`

	// Relative position of node in the Enlight Centre UI
	// Minimum: 0
	Position *int64 `json:"position,omitempty"`

	// Which postal code the site has. Only valid for site type node
	PostalCode string `json:"postalCode,omitempty"`

	// Only valid for asset type nodes
	SerialNumber string `json:"serialNumber,omitempty"`

	// Identifier of shaft that this measurement point belongs to. Only valid for measurement point type nodes
	Shaft string `json:"shaft,omitempty"`

	// Which side of the given shaft this measurement point belongs to. Only valid for measurement point type nodes
	// Enum: [de nde]
	ShaftSide string `json:"shaftSide,omitempty"`

	// Comma separated list of free form tags on this node
	Tags string `json:"tags,omitempty"`

	// Unit of the value recorded, in case of numeric inspection. Only valid for inspection point type nodes
	Unit string `json:"unit,omitempty"`

	// Type of value to record. Only valid for inspection point type nodes
	// Enum: [numeric single_choice multi_choice unknown]
	ValueType string `json:"valueType,omitempty"`

	// Only valid for inspection point type nodes
	VisualizationMaxValue string `json:"visualizationMaxValue,omitempty"`

	// Only valid for inspection point type nodes
	VisualizationMinValue string `json:"visualizationMinValue,omitempty"`

	// Type of visualization in Enlight Centre. Only valid for inspection point type nodes
	// Enum: [visualization_none visualization_circular_gauge visualization_level_gauge]
	VisualizationType string `json:"visualizationType,omitempty"`
}

// Validate validates this node
func (m *Node) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIndustrySegment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLubricantUnit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLubricationActivityAssetState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMeasurementType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetaData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodeSubType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodeType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrientation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrigin(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePosition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShaftSide(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValueType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVisualizationType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nodeTypeIndustrySegmentPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["agriculture","construction","food_and_beverage","hydrocarbon_processing","machine_tool","marine","metal","mining","power_generation","pulp_and_paper","renewable","undefined"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeTypeIndustrySegmentPropEnum = append(nodeTypeIndustrySegmentPropEnum, v)
	}
}

const (

	// NodeIndustrySegmentAgriculture captures enum value "agriculture"
	NodeIndustrySegmentAgriculture string = "agriculture"

	// NodeIndustrySegmentConstruction captures enum value "construction"
	NodeIndustrySegmentConstruction string = "construction"

	// NodeIndustrySegmentFoodAndBeverage captures enum value "food_and_beverage"
	NodeIndustrySegmentFoodAndBeverage string = "food_and_beverage"

	// NodeIndustrySegmentHydrocarbonProcessing captures enum value "hydrocarbon_processing"
	NodeIndustrySegmentHydrocarbonProcessing string = "hydrocarbon_processing"

	// NodeIndustrySegmentMachineTool captures enum value "machine_tool"
	NodeIndustrySegmentMachineTool string = "machine_tool"

	// NodeIndustrySegmentMarine captures enum value "marine"
	NodeIndustrySegmentMarine string = "marine"

	// NodeIndustrySegmentMetal captures enum value "metal"
	NodeIndustrySegmentMetal string = "metal"

	// NodeIndustrySegmentMining captures enum value "mining"
	NodeIndustrySegmentMining string = "mining"

	// NodeIndustrySegmentPowerGeneration captures enum value "power_generation"
	NodeIndustrySegmentPowerGeneration string = "power_generation"

	// NodeIndustrySegmentPulpAndPaper captures enum value "pulp_and_paper"
	NodeIndustrySegmentPulpAndPaper string = "pulp_and_paper"

	// NodeIndustrySegmentRenewable captures enum value "renewable"
	NodeIndustrySegmentRenewable string = "renewable"

	// NodeIndustrySegmentUndefined captures enum value "undefined"
	NodeIndustrySegmentUndefined string = "undefined"
)

// prop value enum
func (m *Node) validateIndustrySegmentEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeTypeIndustrySegmentPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Node) validateIndustrySegment(formats strfmt.Registry) error {

	if swag.IsZero(m.IndustrySegment) { // not required
		return nil
	}

	// value enum
	if err := m.validateIndustrySegmentEnum("industrySegment", "body", m.IndustrySegment); err != nil {
		return err
	}

	return nil
}

var nodeTypeLubricantUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["gram","ounce","cm3","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeTypeLubricantUnitPropEnum = append(nodeTypeLubricantUnitPropEnum, v)
	}
}

const (

	// NodeLubricantUnitGram captures enum value "gram"
	NodeLubricantUnitGram string = "gram"

	// NodeLubricantUnitOunce captures enum value "ounce"
	NodeLubricantUnitOunce string = "ounce"

	// NodeLubricantUnitCm3 captures enum value "cm3"
	NodeLubricantUnitCm3 string = "cm3"

	// NodeLubricantUnitUnknown captures enum value "unknown"
	NodeLubricantUnitUnknown string = "unknown"
)

// prop value enum
func (m *Node) validateLubricantUnitEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeTypeLubricantUnitPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Node) validateLubricantUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.LubricantUnit) { // not required
		return nil
	}

	// value enum
	if err := m.validateLubricantUnitEnum("lubricantUnit", "body", m.LubricantUnit); err != nil {
		return err
	}

	return nil
}

var nodeTypeLubricationActivityAssetStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["must_be_on","must_be_off"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeTypeLubricationActivityAssetStatePropEnum = append(nodeTypeLubricationActivityAssetStatePropEnum, v)
	}
}

const (

	// NodeLubricationActivityAssetStateMustBeOn captures enum value "must_be_on"
	NodeLubricationActivityAssetStateMustBeOn string = "must_be_on"

	// NodeLubricationActivityAssetStateMustBeOff captures enum value "must_be_off"
	NodeLubricationActivityAssetStateMustBeOff string = "must_be_off"
)

// prop value enum
func (m *Node) validateLubricationActivityAssetStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeTypeLubricationActivityAssetStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Node) validateLubricationActivityAssetState(formats strfmt.Registry) error {

	if swag.IsZero(m.LubricationActivityAssetState) { // not required
		return nil
	}

	// value enum
	if err := m.validateLubricationActivityAssetStateEnum("lubricationActivityAssetState", "body", m.LubricationActivityAssetState); err != nil {
		return err
	}

	return nil
}

var nodeTypeMeasurementTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["displacement","acceleration","velocity","temperature","dc_gap","ampl_phase","box","speed","envelope_2","envelope_3","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeTypeMeasurementTypePropEnum = append(nodeTypeMeasurementTypePropEnum, v)
	}
}

const (

	// NodeMeasurementTypeDisplacement captures enum value "displacement"
	NodeMeasurementTypeDisplacement string = "displacement"

	// NodeMeasurementTypeAcceleration captures enum value "acceleration"
	NodeMeasurementTypeAcceleration string = "acceleration"

	// NodeMeasurementTypeVelocity captures enum value "velocity"
	NodeMeasurementTypeVelocity string = "velocity"

	// NodeMeasurementTypeTemperature captures enum value "temperature"
	NodeMeasurementTypeTemperature string = "temperature"

	// NodeMeasurementTypeDcGap captures enum value "dc_gap"
	NodeMeasurementTypeDcGap string = "dc_gap"

	// NodeMeasurementTypeAmplPhase captures enum value "ampl_phase"
	NodeMeasurementTypeAmplPhase string = "ampl_phase"

	// NodeMeasurementTypeBox captures enum value "box"
	NodeMeasurementTypeBox string = "box"

	// NodeMeasurementTypeSpeed captures enum value "speed"
	NodeMeasurementTypeSpeed string = "speed"

	// NodeMeasurementTypeEnvelope2 captures enum value "envelope_2"
	NodeMeasurementTypeEnvelope2 string = "envelope_2"

	// NodeMeasurementTypeEnvelope3 captures enum value "envelope_3"
	NodeMeasurementTypeEnvelope3 string = "envelope_3"

	// NodeMeasurementTypeUnknown captures enum value "unknown"
	NodeMeasurementTypeUnknown string = "unknown"
)

// prop value enum
func (m *Node) validateMeasurementTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeTypeMeasurementTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Node) validateMeasurementType(formats strfmt.Registry) error {

	if swag.IsZero(m.MeasurementType) { // not required
		return nil
	}

	// value enum
	if err := m.validateMeasurementTypeEnum("measurementType", "body", m.MeasurementType); err != nil {
		return err
	}

	return nil
}

func (m *Node) validateMetaData(formats strfmt.Registry) error {

	if swag.IsZero(m.MetaData) { // not required
		return nil
	}

	if err := m.MetaData.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("metaData")
		}
		return err
	}

	return nil
}

var nodeTypeNodeSubTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["root","company","site","plant","ship","system","functional_location","asset","measurement_point","inspection_point","lubrication_point"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeTypeNodeSubTypePropEnum = append(nodeTypeNodeSubTypePropEnum, v)
	}
}

const (

	// NodeNodeSubTypeRoot captures enum value "root"
	NodeNodeSubTypeRoot string = "root"

	// NodeNodeSubTypeCompany captures enum value "company"
	NodeNodeSubTypeCompany string = "company"

	// NodeNodeSubTypeSite captures enum value "site"
	NodeNodeSubTypeSite string = "site"

	// NodeNodeSubTypePlant captures enum value "plant"
	NodeNodeSubTypePlant string = "plant"

	// NodeNodeSubTypeShip captures enum value "ship"
	NodeNodeSubTypeShip string = "ship"

	// NodeNodeSubTypeSystem captures enum value "system"
	NodeNodeSubTypeSystem string = "system"

	// NodeNodeSubTypeFunctionalLocation captures enum value "functional_location"
	NodeNodeSubTypeFunctionalLocation string = "functional_location"

	// NodeNodeSubTypeAsset captures enum value "asset"
	NodeNodeSubTypeAsset string = "asset"

	// NodeNodeSubTypeMeasurementPoint captures enum value "measurement_point"
	NodeNodeSubTypeMeasurementPoint string = "measurement_point"

	// NodeNodeSubTypeInspectionPoint captures enum value "inspection_point"
	NodeNodeSubTypeInspectionPoint string = "inspection_point"

	// NodeNodeSubTypeLubricationPoint captures enum value "lubrication_point"
	NodeNodeSubTypeLubricationPoint string = "lubrication_point"
)

// prop value enum
func (m *Node) validateNodeSubTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeTypeNodeSubTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Node) validateNodeSubType(formats strfmt.Registry) error {

	if swag.IsZero(m.NodeSubType) { // not required
		return nil
	}

	// value enum
	if err := m.validateNodeSubTypeEnum("nodeSubType", "body", m.NodeSubType); err != nil {
		return err
	}

	return nil
}

var nodeTypeNodeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["root","company","site","plant","system","functional_location","asset","measurement_point","inspection_point","lubrication_point","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeTypeNodeTypePropEnum = append(nodeTypeNodeTypePropEnum, v)
	}
}

const (

	// NodeNodeTypeRoot captures enum value "root"
	NodeNodeTypeRoot string = "root"

	// NodeNodeTypeCompany captures enum value "company"
	NodeNodeTypeCompany string = "company"

	// NodeNodeTypeSite captures enum value "site"
	NodeNodeTypeSite string = "site"

	// NodeNodeTypePlant captures enum value "plant"
	NodeNodeTypePlant string = "plant"

	// NodeNodeTypeSystem captures enum value "system"
	NodeNodeTypeSystem string = "system"

	// NodeNodeTypeFunctionalLocation captures enum value "functional_location"
	NodeNodeTypeFunctionalLocation string = "functional_location"

	// NodeNodeTypeAsset captures enum value "asset"
	NodeNodeTypeAsset string = "asset"

	// NodeNodeTypeMeasurementPoint captures enum value "measurement_point"
	NodeNodeTypeMeasurementPoint string = "measurement_point"

	// NodeNodeTypeInspectionPoint captures enum value "inspection_point"
	NodeNodeTypeInspectionPoint string = "inspection_point"

	// NodeNodeTypeLubricationPoint captures enum value "lubrication_point"
	NodeNodeTypeLubricationPoint string = "lubrication_point"

	// NodeNodeTypeUnknown captures enum value "unknown"
	NodeNodeTypeUnknown string = "unknown"
)

// prop value enum
func (m *Node) validateNodeTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeTypeNodeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Node) validateNodeType(formats strfmt.Registry) error {

	if swag.IsZero(m.NodeType) { // not required
		return nil
	}

	// value enum
	if err := m.validateNodeTypeEnum("nodeType", "body", m.NodeType); err != nil {
		return err
	}

	return nil
}

var nodeTypeOrientationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["axial","radial","radial90","horizontal","vertical","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeTypeOrientationPropEnum = append(nodeTypeOrientationPropEnum, v)
	}
}

const (

	// NodeOrientationAxial captures enum value "axial"
	NodeOrientationAxial string = "axial"

	// NodeOrientationRadial captures enum value "radial"
	NodeOrientationRadial string = "radial"

	// NodeOrientationRadial90 captures enum value "radial90"
	NodeOrientationRadial90 string = "radial90"

	// NodeOrientationHorizontal captures enum value "horizontal"
	NodeOrientationHorizontal string = "horizontal"

	// NodeOrientationVertical captures enum value "vertical"
	NodeOrientationVertical string = "vertical"

	// NodeOrientationUnknown captures enum value "unknown"
	NodeOrientationUnknown string = "unknown"
)

// prop value enum
func (m *Node) validateOrientationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeTypeOrientationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Node) validateOrientation(formats strfmt.Registry) error {

	if swag.IsZero(m.Orientation) { // not required
		return nil
	}

	// value enum
	if err := m.validateOrientationEnum("orientation", "body", m.Orientation); err != nil {
		return err
	}

	return nil
}

func (m *Node) validateOrigin(formats strfmt.Registry) error {

	if swag.IsZero(m.Origin) { // not required
		return nil
	}

	if m.Origin != nil {
		if err := m.Origin.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("origin")
			}
			return err
		}
	}

	return nil
}

func (m *Node) validatePosition(formats strfmt.Registry) error {

	if swag.IsZero(m.Position) { // not required
		return nil
	}

	if err := validate.MinimumInt("position", "body", int64(*m.Position), 0, false); err != nil {
		return err
	}

	return nil
}

var nodeTypeShaftSidePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["de","nde"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeTypeShaftSidePropEnum = append(nodeTypeShaftSidePropEnum, v)
	}
}

const (

	// NodeShaftSideDe captures enum value "de"
	NodeShaftSideDe string = "de"

	// NodeShaftSideNde captures enum value "nde"
	NodeShaftSideNde string = "nde"
)

// prop value enum
func (m *Node) validateShaftSideEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeTypeShaftSidePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Node) validateShaftSide(formats strfmt.Registry) error {

	if swag.IsZero(m.ShaftSide) { // not required
		return nil
	}

	// value enum
	if err := m.validateShaftSideEnum("shaftSide", "body", m.ShaftSide); err != nil {
		return err
	}

	return nil
}

var nodeTypeValueTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["numeric","single_choice","multi_choice","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeTypeValueTypePropEnum = append(nodeTypeValueTypePropEnum, v)
	}
}

const (

	// NodeValueTypeNumeric captures enum value "numeric"
	NodeValueTypeNumeric string = "numeric"

	// NodeValueTypeSingleChoice captures enum value "single_choice"
	NodeValueTypeSingleChoice string = "single_choice"

	// NodeValueTypeMultiChoice captures enum value "multi_choice"
	NodeValueTypeMultiChoice string = "multi_choice"

	// NodeValueTypeUnknown captures enum value "unknown"
	NodeValueTypeUnknown string = "unknown"
)

// prop value enum
func (m *Node) validateValueTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeTypeValueTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Node) validateValueType(formats strfmt.Registry) error {

	if swag.IsZero(m.ValueType) { // not required
		return nil
	}

	// value enum
	if err := m.validateValueTypeEnum("valueType", "body", m.ValueType); err != nil {
		return err
	}

	return nil
}

var nodeTypeVisualizationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["visualization_none","visualization_circular_gauge","visualization_level_gauge"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeTypeVisualizationTypePropEnum = append(nodeTypeVisualizationTypePropEnum, v)
	}
}

const (

	// NodeVisualizationTypeVisualizationNone captures enum value "visualization_none"
	NodeVisualizationTypeVisualizationNone string = "visualization_none"

	// NodeVisualizationTypeVisualizationCircularGauge captures enum value "visualization_circular_gauge"
	NodeVisualizationTypeVisualizationCircularGauge string = "visualization_circular_gauge"

	// NodeVisualizationTypeVisualizationLevelGauge captures enum value "visualization_level_gauge"
	NodeVisualizationTypeVisualizationLevelGauge string = "visualization_level_gauge"
)

// prop value enum
func (m *Node) validateVisualizationTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeTypeVisualizationTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Node) validateVisualizationType(formats strfmt.Registry) error {

	if swag.IsZero(m.VisualizationType) { // not required
		return nil
	}

	// value enum
	if err := m.validateVisualizationTypeEnum("visualizationType", "body", m.VisualizationType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Node) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Node) UnmarshalBinary(b []byte) error {
	var res Node
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
