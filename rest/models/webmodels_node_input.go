// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/SKF/go-utility/v2/uuid"
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// WebmodelsNodeInput webmodels node input
//
// swagger:model webmodels.NodeInput
type WebmodelsNodeInput struct {

	// Possible answers for single_choice and multi_choice inspections. Only valid for inspection point type nodes
	Answers []string `json:"answers"`

	// Only valid for asset type nodes
	AssetClass string `json:"assetClass,omitempty"`

	// Only valid for asset type nodes
	AssetSequence string `json:"assetSequence,omitempty"`

	// Only valid for asset type nodes
	AssetType string `json:"assetType,omitempty"`

	// Bearing number on this asset. Only valid for measurement point type nodes
	Bearing int64 `json:"bearing,omitempty"`

	// Which country the node is in. Only valid for site type node
	Country string `json:"country,omitempty"`

	// Only valid for asset type nodes
	Criticality string `json:"criticality,omitempty"`

	// Type of device used to take measurements on this point. Only valid for measurement point type nodes
	DadType string `json:"dadType,omitempty"`

	// Description of the node
	Description string `json:"description,omitempty"`

	// Speed in RPM if this shaft has a fixed speed. Only valid for measurement point type nodes
	FixedSpeedRpm float64 `json:"fixedSpeedRpm,omitempty"`

	// ID of node, as a UUID
	ID uuid.UUID `json:"id,omitempty"`

	// Industry segment of this node. Only valid for site type node
	// Enum: [agriculture construction food_and_beverage hydrocarbon_processing machine_tool marine metal mining power_generation pulp_and_paper renewable undefined]
	IndustrySegment string `json:"industrySegment,omitempty"`

	// Descriptive name of the node
	Label string `json:"label,omitempty"`

	// ID of measurement point location. Only valid for measurement point type nodes
	LocationID uuid.UUID `json:"locationId,omitempty"`

	// Type of lubricant used. Only valid for lubrication point type nodes
	Lubricant string `json:"lubricant,omitempty"`

	// Unit that the volume is specified in. Only valid for lubrication point type nodes
	// Enum: [gram ounce cm3 unknown]
	LubricantUnit string `json:"lubricantUnit,omitempty"`

	// Volume of lubricant, in the given unit. Only valid for lubrication point type nodes
	LubricantVolume int64 `json:"lubricantVolume,omitempty"`

	// Instruction for lubrication activity. Only valid for lubrication point type nodes
	LubricateInstructions string `json:"lubricateInstructions,omitempty"`

	// Interval between lubrication in days. Only valid for lubrication point type nodes
	LubricateInterval int64 `json:"lubricateInterval,omitempty"`

	// ActivityAssetState the asset should be in during the lubrication activity. Only valid for lubrication point type nodes
	// Enum: [must_be_on must_be_off]
	LubricationActivityAssetState string `json:"lubricationActivityAssetState,omitempty"`

	// Only valid for asset type nodes
	Manufacturer string `json:"manufacturer,omitempty"`

	// Type of measurement. Only valid for measurement point type nodes
	// Enum: [displacement acceleration velocity temperature dc dc_gap ampl_phase box manual speed envelope_1 envelope_2 envelope_3 envelope_4 unknown]
	MeasurementType string `json:"measurementType,omitempty"`

	// Metadata with keys and optional values
	MetaData NodeMetaData `json:"metaData,omitempty"`

	// Only valid for asset type nodes
	Model string `json:"model,omitempty"`

	// Type of node
	// Enum: [root company site plant ship system functional_location asset measurement_point inspection_point lubrication_point]
	NodeSubType string `json:"nodeSubType,omitempty"`

	// Type of node
	// Enum: [root company site plant system functional_location asset measurement_point inspection_point lubrication_point unknown]
	NodeType string `json:"nodeType,omitempty"`

	// Orientation of measurement. Only valid for measurement point type nodes
	// Enum: [axial radial radial90 horizontal vertical unknown]
	Orientation string `json:"orientation,omitempty"`

	// Origin of node, if imported from another system
	Origin *Origin `json:"origin,omitempty"`

	// ID of parent node, as a UUID
	ParentID uuid.UUID `json:"parentId,omitempty"`

	// Relative position of node in the Enlight Centre UI
	// Minimum: 0
	Position *int64 `json:"position,omitempty"`

	// Which postal code the site has. Only valid for site type node
	PostalCode string `json:"postalCode,omitempty"`

	// Only valid for asset type nodes
	SerialNumber string `json:"serialNumber,omitempty"`

	// Identifier of shaft that this measurement point belongs to. Only valid for measurement point type nodes
	Shaft string `json:"shaft,omitempty"`

	// Which side of the given shaft this measurement point belongs to. Only valid for measurement point type nodes
	// Enum: [de nde]
	ShaftSide string `json:"shaftSide,omitempty"`

	// Comma separated list of free form tags on this node
	Tags string `json:"tags,omitempty"`

	// Unit of the value recorded, in case of numeric inspection. Only valid for inspection point type nodes
	Unit string `json:"unit,omitempty"`

	// Type of value to record. Only valid for inspection point type nodes
	// Enum: [numeric single_choice multi_choice unknown]
	ValueType string `json:"valueType,omitempty"`

	// Only valid for inspection point type nodes
	VisualizationMaxValue string `json:"visualizationMaxValue,omitempty"`

	// Only valid for inspection point type nodes
	VisualizationMinValue string `json:"visualizationMinValue,omitempty"`

	// Type of visualization in Enlight Centre. Only valid for inspection point type nodes
	// Enum: [visualization_none visualization_circular_gauge visualization_level_gauge]
	VisualizationType string `json:"visualizationType,omitempty"`
}

// Validate validates this webmodels node input
func (m *WebmodelsNodeInput) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIndustrySegment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLubricantUnit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLubricationActivityAssetState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMeasurementType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetaData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodeSubType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodeType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrientation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrigin(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePosition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShaftSide(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValueType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVisualizationType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var webmodelsNodeInputTypeIndustrySegmentPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["agriculture","construction","food_and_beverage","hydrocarbon_processing","machine_tool","marine","metal","mining","power_generation","pulp_and_paper","renewable","undefined"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		webmodelsNodeInputTypeIndustrySegmentPropEnum = append(webmodelsNodeInputTypeIndustrySegmentPropEnum, v)
	}
}

const (

	// WebmodelsNodeInputIndustrySegmentAgriculture captures enum value "agriculture"
	WebmodelsNodeInputIndustrySegmentAgriculture string = "agriculture"

	// WebmodelsNodeInputIndustrySegmentConstruction captures enum value "construction"
	WebmodelsNodeInputIndustrySegmentConstruction string = "construction"

	// WebmodelsNodeInputIndustrySegmentFoodAndBeverage captures enum value "food_and_beverage"
	WebmodelsNodeInputIndustrySegmentFoodAndBeverage string = "food_and_beverage"

	// WebmodelsNodeInputIndustrySegmentHydrocarbonProcessing captures enum value "hydrocarbon_processing"
	WebmodelsNodeInputIndustrySegmentHydrocarbonProcessing string = "hydrocarbon_processing"

	// WebmodelsNodeInputIndustrySegmentMachineTool captures enum value "machine_tool"
	WebmodelsNodeInputIndustrySegmentMachineTool string = "machine_tool"

	// WebmodelsNodeInputIndustrySegmentMarine captures enum value "marine"
	WebmodelsNodeInputIndustrySegmentMarine string = "marine"

	// WebmodelsNodeInputIndustrySegmentMetal captures enum value "metal"
	WebmodelsNodeInputIndustrySegmentMetal string = "metal"

	// WebmodelsNodeInputIndustrySegmentMining captures enum value "mining"
	WebmodelsNodeInputIndustrySegmentMining string = "mining"

	// WebmodelsNodeInputIndustrySegmentPowerGeneration captures enum value "power_generation"
	WebmodelsNodeInputIndustrySegmentPowerGeneration string = "power_generation"

	// WebmodelsNodeInputIndustrySegmentPulpAndPaper captures enum value "pulp_and_paper"
	WebmodelsNodeInputIndustrySegmentPulpAndPaper string = "pulp_and_paper"

	// WebmodelsNodeInputIndustrySegmentRenewable captures enum value "renewable"
	WebmodelsNodeInputIndustrySegmentRenewable string = "renewable"

	// WebmodelsNodeInputIndustrySegmentUndefined captures enum value "undefined"
	WebmodelsNodeInputIndustrySegmentUndefined string = "undefined"
)

// prop value enum
func (m *WebmodelsNodeInput) validateIndustrySegmentEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, webmodelsNodeInputTypeIndustrySegmentPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *WebmodelsNodeInput) validateIndustrySegment(formats strfmt.Registry) error {

	if swag.IsZero(m.IndustrySegment) { // not required
		return nil
	}

	// value enum
	if err := m.validateIndustrySegmentEnum("industrySegment", "body", m.IndustrySegment); err != nil {
		return err
	}

	return nil
}

var webmodelsNodeInputTypeLubricantUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["gram","ounce","cm3","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		webmodelsNodeInputTypeLubricantUnitPropEnum = append(webmodelsNodeInputTypeLubricantUnitPropEnum, v)
	}
}

const (

	// WebmodelsNodeInputLubricantUnitGram captures enum value "gram"
	WebmodelsNodeInputLubricantUnitGram string = "gram"

	// WebmodelsNodeInputLubricantUnitOunce captures enum value "ounce"
	WebmodelsNodeInputLubricantUnitOunce string = "ounce"

	// WebmodelsNodeInputLubricantUnitCm3 captures enum value "cm3"
	WebmodelsNodeInputLubricantUnitCm3 string = "cm3"

	// WebmodelsNodeInputLubricantUnitUnknown captures enum value "unknown"
	WebmodelsNodeInputLubricantUnitUnknown string = "unknown"
)

// prop value enum
func (m *WebmodelsNodeInput) validateLubricantUnitEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, webmodelsNodeInputTypeLubricantUnitPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *WebmodelsNodeInput) validateLubricantUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.LubricantUnit) { // not required
		return nil
	}

	// value enum
	if err := m.validateLubricantUnitEnum("lubricantUnit", "body", m.LubricantUnit); err != nil {
		return err
	}

	return nil
}

var webmodelsNodeInputTypeLubricationActivityAssetStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["must_be_on","must_be_off"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		webmodelsNodeInputTypeLubricationActivityAssetStatePropEnum = append(webmodelsNodeInputTypeLubricationActivityAssetStatePropEnum, v)
	}
}

const (

	// WebmodelsNodeInputLubricationActivityAssetStateMustBeOn captures enum value "must_be_on"
	WebmodelsNodeInputLubricationActivityAssetStateMustBeOn string = "must_be_on"

	// WebmodelsNodeInputLubricationActivityAssetStateMustBeOff captures enum value "must_be_off"
	WebmodelsNodeInputLubricationActivityAssetStateMustBeOff string = "must_be_off"
)

// prop value enum
func (m *WebmodelsNodeInput) validateLubricationActivityAssetStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, webmodelsNodeInputTypeLubricationActivityAssetStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *WebmodelsNodeInput) validateLubricationActivityAssetState(formats strfmt.Registry) error {

	if swag.IsZero(m.LubricationActivityAssetState) { // not required
		return nil
	}

	// value enum
	if err := m.validateLubricationActivityAssetStateEnum("lubricationActivityAssetState", "body", m.LubricationActivityAssetState); err != nil {
		return err
	}

	return nil
}

var webmodelsNodeInputTypeMeasurementTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["displacement","acceleration","velocity","temperature","dc","dc_gap","ampl_phase","box","manual","speed","envelope_1","envelope_2","envelope_3","envelope_4","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		webmodelsNodeInputTypeMeasurementTypePropEnum = append(webmodelsNodeInputTypeMeasurementTypePropEnum, v)
	}
}

const (

	// WebmodelsNodeInputMeasurementTypeDisplacement captures enum value "displacement"
	WebmodelsNodeInputMeasurementTypeDisplacement string = "displacement"

	// WebmodelsNodeInputMeasurementTypeAcceleration captures enum value "acceleration"
	WebmodelsNodeInputMeasurementTypeAcceleration string = "acceleration"

	// WebmodelsNodeInputMeasurementTypeVelocity captures enum value "velocity"
	WebmodelsNodeInputMeasurementTypeVelocity string = "velocity"

	// WebmodelsNodeInputMeasurementTypeTemperature captures enum value "temperature"
	WebmodelsNodeInputMeasurementTypeTemperature string = "temperature"

	// WebmodelsNodeInputMeasurementTypeDc captures enum value "dc"
	WebmodelsNodeInputMeasurementTypeDc string = "dc"

	// WebmodelsNodeInputMeasurementTypeDcGap captures enum value "dc_gap"
	WebmodelsNodeInputMeasurementTypeDcGap string = "dc_gap"

	// WebmodelsNodeInputMeasurementTypeAmplPhase captures enum value "ampl_phase"
	WebmodelsNodeInputMeasurementTypeAmplPhase string = "ampl_phase"

	// WebmodelsNodeInputMeasurementTypeBox captures enum value "box"
	WebmodelsNodeInputMeasurementTypeBox string = "box"

	// WebmodelsNodeInputMeasurementTypeManual captures enum value "manual"
	WebmodelsNodeInputMeasurementTypeManual string = "manual"

	// WebmodelsNodeInputMeasurementTypeSpeed captures enum value "speed"
	WebmodelsNodeInputMeasurementTypeSpeed string = "speed"

	// WebmodelsNodeInputMeasurementTypeEnvelope1 captures enum value "envelope_1"
	WebmodelsNodeInputMeasurementTypeEnvelope1 string = "envelope_1"

	// WebmodelsNodeInputMeasurementTypeEnvelope2 captures enum value "envelope_2"
	WebmodelsNodeInputMeasurementTypeEnvelope2 string = "envelope_2"

	// WebmodelsNodeInputMeasurementTypeEnvelope3 captures enum value "envelope_3"
	WebmodelsNodeInputMeasurementTypeEnvelope3 string = "envelope_3"

	// WebmodelsNodeInputMeasurementTypeEnvelope4 captures enum value "envelope_4"
	WebmodelsNodeInputMeasurementTypeEnvelope4 string = "envelope_4"

	// WebmodelsNodeInputMeasurementTypeUnknown captures enum value "unknown"
	WebmodelsNodeInputMeasurementTypeUnknown string = "unknown"
)

// prop value enum
func (m *WebmodelsNodeInput) validateMeasurementTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, webmodelsNodeInputTypeMeasurementTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *WebmodelsNodeInput) validateMeasurementType(formats strfmt.Registry) error {

	if swag.IsZero(m.MeasurementType) { // not required
		return nil
	}

	// value enum
	if err := m.validateMeasurementTypeEnum("measurementType", "body", m.MeasurementType); err != nil {
		return err
	}

	return nil
}

func (m *WebmodelsNodeInput) validateMetaData(formats strfmt.Registry) error {

	if swag.IsZero(m.MetaData) { // not required
		return nil
	}

	if err := m.MetaData.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("metaData")
		}
		return err
	}

	return nil
}

var webmodelsNodeInputTypeNodeSubTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["root","company","site","plant","ship","system","functional_location","asset","measurement_point","inspection_point","lubrication_point"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		webmodelsNodeInputTypeNodeSubTypePropEnum = append(webmodelsNodeInputTypeNodeSubTypePropEnum, v)
	}
}

const (

	// WebmodelsNodeInputNodeSubTypeRoot captures enum value "root"
	WebmodelsNodeInputNodeSubTypeRoot string = "root"

	// WebmodelsNodeInputNodeSubTypeCompany captures enum value "company"
	WebmodelsNodeInputNodeSubTypeCompany string = "company"

	// WebmodelsNodeInputNodeSubTypeSite captures enum value "site"
	WebmodelsNodeInputNodeSubTypeSite string = "site"

	// WebmodelsNodeInputNodeSubTypePlant captures enum value "plant"
	WebmodelsNodeInputNodeSubTypePlant string = "plant"

	// WebmodelsNodeInputNodeSubTypeShip captures enum value "ship"
	WebmodelsNodeInputNodeSubTypeShip string = "ship"

	// WebmodelsNodeInputNodeSubTypeSystem captures enum value "system"
	WebmodelsNodeInputNodeSubTypeSystem string = "system"

	// WebmodelsNodeInputNodeSubTypeFunctionalLocation captures enum value "functional_location"
	WebmodelsNodeInputNodeSubTypeFunctionalLocation string = "functional_location"

	// WebmodelsNodeInputNodeSubTypeAsset captures enum value "asset"
	WebmodelsNodeInputNodeSubTypeAsset string = "asset"

	// WebmodelsNodeInputNodeSubTypeMeasurementPoint captures enum value "measurement_point"
	WebmodelsNodeInputNodeSubTypeMeasurementPoint string = "measurement_point"

	// WebmodelsNodeInputNodeSubTypeInspectionPoint captures enum value "inspection_point"
	WebmodelsNodeInputNodeSubTypeInspectionPoint string = "inspection_point"

	// WebmodelsNodeInputNodeSubTypeLubricationPoint captures enum value "lubrication_point"
	WebmodelsNodeInputNodeSubTypeLubricationPoint string = "lubrication_point"
)

// prop value enum
func (m *WebmodelsNodeInput) validateNodeSubTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, webmodelsNodeInputTypeNodeSubTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *WebmodelsNodeInput) validateNodeSubType(formats strfmt.Registry) error {

	if swag.IsZero(m.NodeSubType) { // not required
		return nil
	}

	// value enum
	if err := m.validateNodeSubTypeEnum("nodeSubType", "body", m.NodeSubType); err != nil {
		return err
	}

	return nil
}

var webmodelsNodeInputTypeNodeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["root","company","site","plant","system","functional_location","asset","measurement_point","inspection_point","lubrication_point","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		webmodelsNodeInputTypeNodeTypePropEnum = append(webmodelsNodeInputTypeNodeTypePropEnum, v)
	}
}

const (

	// WebmodelsNodeInputNodeTypeRoot captures enum value "root"
	WebmodelsNodeInputNodeTypeRoot string = "root"

	// WebmodelsNodeInputNodeTypeCompany captures enum value "company"
	WebmodelsNodeInputNodeTypeCompany string = "company"

	// WebmodelsNodeInputNodeTypeSite captures enum value "site"
	WebmodelsNodeInputNodeTypeSite string = "site"

	// WebmodelsNodeInputNodeTypePlant captures enum value "plant"
	WebmodelsNodeInputNodeTypePlant string = "plant"

	// WebmodelsNodeInputNodeTypeSystem captures enum value "system"
	WebmodelsNodeInputNodeTypeSystem string = "system"

	// WebmodelsNodeInputNodeTypeFunctionalLocation captures enum value "functional_location"
	WebmodelsNodeInputNodeTypeFunctionalLocation string = "functional_location"

	// WebmodelsNodeInputNodeTypeAsset captures enum value "asset"
	WebmodelsNodeInputNodeTypeAsset string = "asset"

	// WebmodelsNodeInputNodeTypeMeasurementPoint captures enum value "measurement_point"
	WebmodelsNodeInputNodeTypeMeasurementPoint string = "measurement_point"

	// WebmodelsNodeInputNodeTypeInspectionPoint captures enum value "inspection_point"
	WebmodelsNodeInputNodeTypeInspectionPoint string = "inspection_point"

	// WebmodelsNodeInputNodeTypeLubricationPoint captures enum value "lubrication_point"
	WebmodelsNodeInputNodeTypeLubricationPoint string = "lubrication_point"

	// WebmodelsNodeInputNodeTypeUnknown captures enum value "unknown"
	WebmodelsNodeInputNodeTypeUnknown string = "unknown"
)

// prop value enum
func (m *WebmodelsNodeInput) validateNodeTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, webmodelsNodeInputTypeNodeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *WebmodelsNodeInput) validateNodeType(formats strfmt.Registry) error {

	if swag.IsZero(m.NodeType) { // not required
		return nil
	}

	// value enum
	if err := m.validateNodeTypeEnum("nodeType", "body", m.NodeType); err != nil {
		return err
	}

	return nil
}

var webmodelsNodeInputTypeOrientationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["axial","radial","radial90","horizontal","vertical","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		webmodelsNodeInputTypeOrientationPropEnum = append(webmodelsNodeInputTypeOrientationPropEnum, v)
	}
}

const (

	// WebmodelsNodeInputOrientationAxial captures enum value "axial"
	WebmodelsNodeInputOrientationAxial string = "axial"

	// WebmodelsNodeInputOrientationRadial captures enum value "radial"
	WebmodelsNodeInputOrientationRadial string = "radial"

	// WebmodelsNodeInputOrientationRadial90 captures enum value "radial90"
	WebmodelsNodeInputOrientationRadial90 string = "radial90"

	// WebmodelsNodeInputOrientationHorizontal captures enum value "horizontal"
	WebmodelsNodeInputOrientationHorizontal string = "horizontal"

	// WebmodelsNodeInputOrientationVertical captures enum value "vertical"
	WebmodelsNodeInputOrientationVertical string = "vertical"

	// WebmodelsNodeInputOrientationUnknown captures enum value "unknown"
	WebmodelsNodeInputOrientationUnknown string = "unknown"
)

// prop value enum
func (m *WebmodelsNodeInput) validateOrientationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, webmodelsNodeInputTypeOrientationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *WebmodelsNodeInput) validateOrientation(formats strfmt.Registry) error {

	if swag.IsZero(m.Orientation) { // not required
		return nil
	}

	// value enum
	if err := m.validateOrientationEnum("orientation", "body", m.Orientation); err != nil {
		return err
	}

	return nil
}

func (m *WebmodelsNodeInput) validateOrigin(formats strfmt.Registry) error {

	if swag.IsZero(m.Origin) { // not required
		return nil
	}

	if m.Origin != nil {
		if err := m.Origin.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("origin")
			}
			return err
		}
	}

	return nil
}

func (m *WebmodelsNodeInput) validatePosition(formats strfmt.Registry) error {

	if swag.IsZero(m.Position) { // not required
		return nil
	}

	if err := validate.MinimumInt("position", "body", int64(*m.Position), 0, false); err != nil {
		return err
	}

	return nil
}

var webmodelsNodeInputTypeShaftSidePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["de","nde"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		webmodelsNodeInputTypeShaftSidePropEnum = append(webmodelsNodeInputTypeShaftSidePropEnum, v)
	}
}

const (

	// WebmodelsNodeInputShaftSideDe captures enum value "de"
	WebmodelsNodeInputShaftSideDe string = "de"

	// WebmodelsNodeInputShaftSideNde captures enum value "nde"
	WebmodelsNodeInputShaftSideNde string = "nde"
)

// prop value enum
func (m *WebmodelsNodeInput) validateShaftSideEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, webmodelsNodeInputTypeShaftSidePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *WebmodelsNodeInput) validateShaftSide(formats strfmt.Registry) error {

	if swag.IsZero(m.ShaftSide) { // not required
		return nil
	}

	// value enum
	if err := m.validateShaftSideEnum("shaftSide", "body", m.ShaftSide); err != nil {
		return err
	}

	return nil
}

var webmodelsNodeInputTypeValueTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["numeric","single_choice","multi_choice","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		webmodelsNodeInputTypeValueTypePropEnum = append(webmodelsNodeInputTypeValueTypePropEnum, v)
	}
}

const (

	// WebmodelsNodeInputValueTypeNumeric captures enum value "numeric"
	WebmodelsNodeInputValueTypeNumeric string = "numeric"

	// WebmodelsNodeInputValueTypeSingleChoice captures enum value "single_choice"
	WebmodelsNodeInputValueTypeSingleChoice string = "single_choice"

	// WebmodelsNodeInputValueTypeMultiChoice captures enum value "multi_choice"
	WebmodelsNodeInputValueTypeMultiChoice string = "multi_choice"

	// WebmodelsNodeInputValueTypeUnknown captures enum value "unknown"
	WebmodelsNodeInputValueTypeUnknown string = "unknown"
)

// prop value enum
func (m *WebmodelsNodeInput) validateValueTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, webmodelsNodeInputTypeValueTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *WebmodelsNodeInput) validateValueType(formats strfmt.Registry) error {

	if swag.IsZero(m.ValueType) { // not required
		return nil
	}

	// value enum
	if err := m.validateValueTypeEnum("valueType", "body", m.ValueType); err != nil {
		return err
	}

	return nil
}

var webmodelsNodeInputTypeVisualizationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["visualization_none","visualization_circular_gauge","visualization_level_gauge"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		webmodelsNodeInputTypeVisualizationTypePropEnum = append(webmodelsNodeInputTypeVisualizationTypePropEnum, v)
	}
}

const (

	// WebmodelsNodeInputVisualizationTypeVisualizationNone captures enum value "visualization_none"
	WebmodelsNodeInputVisualizationTypeVisualizationNone string = "visualization_none"

	// WebmodelsNodeInputVisualizationTypeVisualizationCircularGauge captures enum value "visualization_circular_gauge"
	WebmodelsNodeInputVisualizationTypeVisualizationCircularGauge string = "visualization_circular_gauge"

	// WebmodelsNodeInputVisualizationTypeVisualizationLevelGauge captures enum value "visualization_level_gauge"
	WebmodelsNodeInputVisualizationTypeVisualizationLevelGauge string = "visualization_level_gauge"
)

// prop value enum
func (m *WebmodelsNodeInput) validateVisualizationTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, webmodelsNodeInputTypeVisualizationTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *WebmodelsNodeInput) validateVisualizationType(formats strfmt.Registry) error {

	if swag.IsZero(m.VisualizationType) { // not required
		return nil
	}

	// value enum
	if err := m.validateVisualizationTypeEnum("visualizationType", "body", m.VisualizationType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *WebmodelsNodeInput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *WebmodelsNodeInput) UnmarshalBinary(b []byte) error {
	var res WebmodelsNodeInput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
